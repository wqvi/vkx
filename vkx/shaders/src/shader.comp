#version 450

struct Voxel
{
    uint type;
    bool visible;
};

struct VoxelMask
{
    Voxel voxel;
    int normal;
};

struct Vertex
{
    vec3 pos;
    vec2 uv;
    vec3 normal;
};

#define VOXEL_LIMIT 64
#define MASK_LIMIT VOXEL_LIMIT * VOXEL_LIMIT
#define MAX_VOXELS VOXEL_LIMIT * VOXEL_LIMIT * VOXEL_LIMIT

int index3D(int x, int y, int z)
{
    return z * VOXEL_LIMIT * VOXEL_LIMIT + y * VOXEL_LIMIT + x;
}

int index2D(int x, int y)
{
    return x + VOXEL_LIMIT * y;
}

bool isValidLocation(in ivec3 itr)
{
	return itr.x >= 0 && itr.x < VOXEL_LIMIT && itr.y >= 0 && itr.y < VOXEL_LIMIT && itr.z >= 0 && itr.z < VOXEL_LIMIT;
}

Voxel getVoxelArray(in Voxel voxels[MAX_VOXELS], in ivec3 itr)
{
	if (!isValidLocation(itr))
	{
		return Voxel(0, false);
	}
	return voxels[index3D(itr.x, itr.y, itr.z)];
}

void computeMask(in Voxel voxels[MAX_VOXELS], inout VoxelMask mask[MASK_LIMIT], inout ivec3 itr, in ivec3 axisMask)
{
	for (int y = 0; y < VOXEL_LIMIT; y++)
	{
		for (int x = 0; x < VOXEL_LIMIT; x++)
		{
			const Voxel currentVoxel = getVoxelArray(voxels, itr);
			const Voxel compareVoxel = getVoxelArray(voxels, itr + axisMask);
			
            const int index = index2D(x, y);
			if (currentVoxel.visible == compareVoxel.visible)
			{
				mask[index] = VoxelMask(Voxel(0, false), 0);
			} else if (currentVoxel.visible)
			{
				mask[index] = VoxelMask(currentVoxel, 1);
			} else
			{
				mask[index] = VoxelMask(compareVoxel, -1);
			}
		}
	}
}

bool compareVoxel(in Voxel lhs, in Voxel rhs)
{
	return lhs.type == rhs.type && lhs.visible == rhs.visible;
}

bool compareMask(in VoxelMask lhs, in VoxelMask rhs)
{
	return compareVoxel(lhs.voxel, rhs.voxel) && lhs.normal == rhs.normal;
}

int calculateQuadWidth(in VoxelMask voxelMask[MASK_LIMIT], in VoxelMask mask, in int x, in int y)
{
	int width = 1;
    const int index = index2D(x, y);
	while (x + width < VOXEL_LIMIT && compareMask(voxelMask[index + width], mask))
	{
		width++;
	}
	return width;
}

int calculateQuadHeight(in VoxelMask voxelMask[MASK_LIMIT], in VoxelMask mask, in int width, in int x, in int y)
{
	int height = 1;
	while (y + height < VOXEL_LIMIT)
	{
		for (int i = 0; i < width; i++)
		{
            const int index = index2D(x, y) + i + height * width;
			if (!compareMask(voxelMask[index], mask))
			{
				return height;
			}
		}
	}
	return height;
}

void createQuadMesh(VoxelMask mask, ivec3 itr, ivec3 axisMask, int quadWidth, int quadHeight, int axis1, int axis2)
{
    ivec3 deltaAxis1;
    ivec3 deltaAxis2;
    deltaAxis1[axis1] = quadWidth;
    deltaAxis2[axis2] = quadHeight;

    vec3 normal = axisMask * mask.normal;

    vec3 a = itr;
    vec3 b = itr + deltaAxis1;
    vec3 c = itr + deltaAxis2;
    vec3 d = itr + deltaAxis1 + deltaAxis2;

    Vertex v1 = Vertex(-a, vec2(0, 0), -normal);
    Vertex v2 = Vertex(-b, vec2(quadWidth, 0), -normal);
    Vertex v3 = Vertex(-c, vec2(0, quadHeight), -normal);
    Vertex v4 = Vertex(-d, vec2(quadWidth, quadHeight), -normal);

    // Calculate indices of mesh
}

void clearMesh(inout VoxelMask mask[MASK_LIMIT], in int x, in int y)
{
	for (int i = 0; i < VOXEL_LIMIT; i++)
    {
        for (int j = 0; j < VOXEL_LIMIT; j++)
        {
            const int index = index2D(x + j, y + i);
            mask[index] = VoxelMask(Voxel(0, false), 0);
        }
    }
}

void generateMaskMesh(inout VoxelMask mask[MASK_LIMIT], in int axis1, in int axis2, inout ivec3 itr, in ivec3 axisMask)
{
	for (int y = 0; y < VOXEL_LIMIT; y++)
	{
		for (int x = 0; x < VOXEL_LIMIT; x++)
		{
			const int index = x + VOXEL_LIMIT * y;
			const VoxelMask currentMask = mask[index];
			if (currentMask.normal != 0)
			{
				itr[axis1] = x;
				itr[axis2] = y;
				
				const int quadWidth = calculateQuadWidth(mask, currentMask, x, y);
				const int quadHeight = calculateQuadHeight(mask, currentMask, quadWidth, x, y);
				
				// Create quad mesh
				createQuadMesh(currentMask, itr, axisMask, quadWidth, quadHeight, axis1, axis2);
				
				// Clear mask
				clearMesh(mask, x, y);
			}
		}
	}
}

void generate(in Voxel voxels[MAX_VOXELS])
{
    for (int axis = 0; axis < 3; axis++)
    {
        const int axis1 = (axis + 1) % 3;
        const int axis2 = (axis + 2) % 3;

        ivec3 itr = ivec3(0);
        ivec3 axisMask = ivec3(0);

        VoxelMask mask[MASK_LIMIT];

        // Iterate through each slice of the chunk
        for (itr[axis] = -1; itr[axis] < VOXEL_LIMIT;)
        {
            // Compute mask
			computeMask(voxels, mask, itr, axisMask);
			
			// Iterate
            itr[axis]++;

            // Generate mesh
            generateMaskMesh(mask, axis1, axis2, itr, axisMask);
        }
    }
}

void main()
{
    uint gID = gl_GlobalInvocationID.x;
    Voxel voxels[MAX_VOXELS];
    generate(voxels);
}